<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>NEON NEEDLE BLAST - OVERDRIVE</title>
  <style>
    /* ＝＝＝ CSS: デザインとレイアウト ＝＝＝ */
    :root {
      --bg-color: #050510;
      --text-color: #fff;
      --neon-cyan: #00ffff;
      --neon-pink: #ff00ff;
      --neon-yellow: #ffff00;
      --neon-red: #ff2a2a;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: 'Orbitron', 'Segoe UI', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      user-select: none;
      touch-action: manipulation;
    }

    #gameWrapper {
      position: relative;
      width: 100%;
      max-width: 400px;
      height: 650px;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
      display: flex;
      flex-direction: column;
    }

    #canvasContainer {
      position: relative;
      flex-grow: 1;
      width: 100%;
      background: radial-gradient(circle at center, #1a1a2e 0%, #050510 100%);
      overflow: hidden;
    }

    canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }

    /* UI表示エリア */
    #uiContainer {
      position: absolute;
      top: 15px;
      left: 0;
      width: 100%;
      padding: 0 20px;
      pointer-events: none;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      z-index: 10;
    }
    .score-box { text-align: left; text-shadow: 0 0 5px var(--neon-cyan); }
    .score-label { font-size: 14px; color: var(--neon-cyan); }
    #scoreValue { font-size: 26px; font-weight: bold; }

    .combo-box { text-align: right; text-shadow: 0 0 10px var(--neon-pink); }
    #comboValue { font-size: 30px; font-weight: bold; color: var(--neon-pink); }
    .combo-label { font-size: 14px; color: var(--neon-pink); }

    /* WAVE・FEVER 表示エリア */
    #centerInfo {
      position: absolute;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      pointer-events: none;
      z-index: 10;
    }
    #waveDisplay {
      font-size: 18px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 8px #fff;
      letter-spacing: 2px;
    }

    #feverIndicator {
      margin-top: 5px;
      font-size: 24px;
      font-weight: bold;
      color: var(--neon-yellow);
      text-shadow: 0 0 20px var(--neon-yellow), 0 0 40px var(--neon-yellow);
      opacity: 0;
      transition: opacity 0.3s;
    }
    #feverIndicator.active {
      opacity: 1;
      animation: pulse 0.5s infinite alternate;
    }
    @keyframes pulse {
      from { transform: scale(1); }
      to { transform: scale(1.1); }
    }

    /* WAVE警告アニメーション */
    #waveWarning {
      position: absolute;
      top: 45%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 38px;
      font-weight: bold;
      color: var(--neon-red);
      text-shadow: 0 0 20px var(--neon-red), 0 0 40px var(--neon-red);
      text-align: center;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      z-index: 20;
    }
    .warn-anim {
      animation: warningFlash 2.5s cubic-bezier(0.1, 0.8, 0.1, 1);
    }
    @keyframes warningFlash {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      10% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
      20% { opacity: 0.3; transform: translate(-50%, -50%) scale(1); }
      30% { opacity: 1; }
      40% { opacity: 0.3; }
      50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
    }

    /* 武器切り替えUI */
    #weaponSelect {
      display: flex;
      height: 70px;
      background-color: #0a0a1a;
      border-top: 2px solid #333;
    }
    .wpn-btn {
      flex: 1;
      background: transparent;
      border: none;
      border-right: 1px solid #333;
      color: #888;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      transition: all 0.2s;
    }
    .wpn-btn:last-child { border-right: none; }
    .wpn-btn.active { color: #fff; background-color: rgba(255,255,255,0.1); }
    
    #btnWpn0.active { box-shadow: inset 0 -4px 0 var(--neon-cyan); text-shadow: 0 0 5px var(--neon-cyan); }
    #btnWpn1.active { box-shadow: inset 0 -4px 0 var(--neon-red); text-shadow: 0 0 5px var(--neon-red); }
    #btnWpn2.active { box-shadow: inset 0 -4px 0 var(--neon-yellow); text-shadow: 0 0 5px var(--neon-yellow); }

    .cooldown-fill {
      position: absolute;
      bottom: 0; left: 0; width: 100%; height: 0%;
      background-color: rgba(255, 0, 0, 0.3);
      z-index: -1;
      transition: height 0.1s linear;
    }
    #btnWpn2 .cooldown-fill { background-color: rgba(255, 255, 0, 0.3); }

    /* フィーバー時の無双UIエフェクト */
    body.fever-mode #weaponSelect {
      box-shadow: 0 -10px 30px rgba(255, 255, 0, 0.4);
      animation: feverBorder 0.5s infinite alternate;
    }
    @keyframes feverBorder {
      from { border-top-color: var(--neon-yellow); }
      to { border-top-color: #fff; }
    }

  </style>
</head>
<body>

  <div id="gameWrapper">
    <div id="canvasContainer">
      <canvas id="gameCanvas"></canvas>
      <div id="uiContainer">
        <div class="score-box">
          <div class="score-label">SCORE</div>
          <div id="scoreValue">0</div>
        </div>
        <div id="centerInfo">
          <div id="waveDisplay">WAVE <span id="waveValue">1</span></div>
          <div id="feverIndicator">NO COOLDOWN!</div>
        </div>
        <div class="combo-box">
          <div id="comboValue">0</div>
          <div class="combo-label">COMBO!</div>
        </div>
      </div>
      <div id="waveWarning"></div>
    </div>
    
    <div id="weaponSelect">
      <button class="wpn-btn active" id="btnWpn0" onclick="setWeapon(0)">
        1. NORMAL
        <div class="cooldown-fill" id="cdFill0"></div>
      </button>
      <button class="wpn-btn" id="btnWpn1" onclick="setWeapon(1)">
        2. BOMB
        <div class="cooldown-fill" id="cdFill1"></div>
      </button>
      <button class="wpn-btn" id="btnWpn2" onclick="setWeapon(2)">
        3. LASER
        <div class="cooldown-fill" id="cdFill2"></div>
      </button>
    </div>
  </div>

  <script>
    /* ＝＝＝ JavaScript: ゲームロジックと演出 ＝＝＝ */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    function resizeCanvas() {
      const container = document.getElementById('canvasContainer');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // --- ★設定・パラメータ★ ---
    const CONFIG = {
      TARGET_RADIUS: 50,
      PIN_LENGTH: 90,
      PIN_HEAD_RADIUS: 6,
      BASE_ROTATION_SPEED: 0.02,
      FLY_SPEED: 45,
      COLLISION_MARGIN: 0.15,

      HITSTOP_FRAMES_NORMAL: 3,
      HITSTOP_FRAMES_DESTROY: 6,
      HITSTOP_FRAMES_HEAVY: 12,
      FLASH_DECAY: 0.08,
      
      // 武器設定
      WEAPONS: [
        { id: 0, color: '#00ffff', name: 'NORMAL', cdTime: 0 },
        { id: 1, color: '#ff2a2a', name: 'BOMB', cdTime: 90 }, // 通常1.5秒
        { id: 2, color: '#ffff00', name: 'LASER', cdTime: 300 } // 通常5秒
      ],

      // WAVE進捗のスコア閾値
      WAVE_THRESHOLDS: [0, 1500, 4000, 8000, 15000, 25000]
    };

    // --- ゲームのステート ---
    let state = {
      score: 0, combo: 0,
      wave: 1,
      
      // 的の状態
      rotationAngle: 0,
      targetX: 0, targetY: 0, // 的の現在座標（ムービング用）
      timePhase: 0,           // ムービング計算用の時間
      shields: [],            // シールドの配列

      pins: [], flyingPins: [], particles: [], floatingTexts: [],
      
      hitstopTimer: 0, screenShakeTimer: 0, shakeMagnitude: 0, flashAlpha: 0, laserBeamTimer: 0,
      feverEndTime: 0, isFever: false,
      currentWeapon: 0, cooldowns: [0, 0, 0]
    };

    let CENTER_X, CENTER_Y, WAIT_PIN_Y;

    // --- ユーティリティ ---
    const random = (min, max) => Math.random() * (max - min) + min;
    const normalizeAngle = (angle) => angle - Math.PI * 2 * Math.floor(angle / (Math.PI * 2));
    const getAngleDiff = (a, b) => {
      let diff = Math.abs(a - b);
      return diff > Math.PI ? Math.PI * 2 - diff : diff;
    };

    // --- 演出関数 ---
    function applyHitstop(frames) { state.hitstopTimer = Math.max(state.hitstopTimer, frames); }
    function applyScreenShake(frames, mag) { state.screenShakeTimer = Math.max(state.screenShakeTimer, frames); state.shakeMagnitude = mag; }
    function applyFlash(intensity = 0.5) { state.flashAlpha = Math.max(state.flashAlpha, intensity); }

    function spawnParticles(x, y, color, count, speed, size) {
      for (let i = 0; i < count; i++) {
        const ang = random(0, Math.PI * 2); const s = random(speed * 0.5, speed * 1.5);
        state.particles.push({
          x, y, vx: Math.cos(ang) * s, vy: Math.sin(ang) * s,
          color, size: random(size * 0.5, size * 1.5), life: 1.0, decay: random(0.02, 0.06)
        });
      }
    }

    function spawnFloatingText(x, y, text, color, size = 20) {
      state.floatingTexts.push({
        x: x + random(-10, 10), y: y + random(-10, 10),
        text, color, size, life: 1.0, vy: -1.5
      });
    }

    // --- ★ WAVE・ギミック管理のロジック ★ ---

    function checkWaveProgress() {
      const nextThreshold = CONFIG.WAVE_THRESHOLDS[state.wave] || (state.wave * 15000);
      if (state.score >= nextThreshold) {
        startNextWave();
      }
    }

    function startNextWave() {
      state.wave++;
      document.getElementById('waveValue').innerText = state.wave;
      
      // 警告テキストの表示（CSSアニメーションの再起動）
      const warnEl = document.getElementById('waveWarning');
      warnEl.innerText = `WAVE ${state.wave} START!`;
      warnEl.classList.remove('warn-anim');
      void warnEl.offsetWidth; // リフローを強制してアニメーションをリセット
      warnEl.classList.add('warn-anim');

      applyScreenShake(30, 15);
      applyFlash(0.8);

      // WAVE3以降はシールドを生成
      generateShields(state.wave);
    }

    // WAVEに応じたシールド（赤いバリア）の生成
    function generateShields(wave) {
      state.shields = [];
      if (wave < 3) return; // WAVE 1, 2はシールドなし
      
      // WAVEが上がるごとにシールドの数が増える（最大4つ）
      const count = Math.min(wave - 1, 4); 
      const span = Math.PI / 4; // シールドのカバー範囲（45度）
      
      for (let i = 0; i < count; i++) {
        state.shields.push({
          angleOffset: (Math.PI * 2 / count) * i, // 的に対する相対角度
          span: span,
          active: true
        });
      }
    }

    // --- 武器発射 ---
    function setWeapon(index) {
      state.currentWeapon = index;
      document.querySelectorAll('.wpn-btn').forEach((btn, i) => btn.classList.toggle('active', i === index));
    }

    function shoot() {
      const wp = CONFIG.WEAPONS[state.currentWeapon];
      
      // ★ フィーバー覚醒：クールダウン無視の無双状態 ★
      if (!state.isFever && state.cooldowns[state.currentWeapon] > 0) return;

      if (state.currentWeapon === 0 || state.currentWeapon === 1) {
        state.flyingPins.push({ y: WAIT_PIN_Y, type: state.currentWeapon });
      } else if (state.currentWeapon === 2) {
        fireLaser();
      }

      // フィーバー中はクールダウンを発生させない
      if (!state.isFever) {
        state.cooldowns[state.currentWeapon] = wp.cdTime;
      }
    }

    // --- レーザー発射処理 ---
    function fireLaser() {
      state.laserBeamTimer = 15;
      applyHitstop(CONFIG.HITSTOP_FRAMES_HEAVY);
      applyScreenShake(20, 15);
      applyFlash(0.8);
      
      let destroyedCount = 0;
      
      // 1. 既存の針の破壊（レーザーの軌道上 = 画面中央のX座標に近いもの）
      const newPins = [];
      state.pins.forEach(pinAngle => {
        const absAngle = normalizeAngle(state.rotationAngle + pinAngle);
        const pinAbsX = state.targetX + Math.cos(absAngle) * CONFIG.TARGET_RADIUS;
        const pinAbsY = state.targetY + Math.sin(absAngle) * CONFIG.TARGET_RADIUS;
        
        // レーザーの幅（±20px）に入っている針を破壊
        if (Math.abs(pinAbsX - CENTER_X) < 20 && pinAbsY >= state.targetY) {
          destroyedCount++;
          spawnParticles(pinAbsX, pinAbsY, '#ffff00', 8, 8, 4);
        } else {
          newPins.push(pinAngle);
        }
      });
      state.pins = newPins;

      // 2. シールドの破壊（レーザー軌道上のシールドを粉砕）
      state.shields.forEach(sh => {
        if (!sh.active) return;
        const shAbsAngle = normalizeAngle(state.rotationAngle + sh.angleOffset);
        // シールドの中心が真下（Math.PI/2）に近い場合破壊
        if (getAngleDiff(shAbsAngle, Math.PI / 2) < sh.span / 2 + 0.3) {
          sh.active = false;
          destroyedCount++;
          spawnParticles(CENTER_X, state.targetY + CONFIG.TARGET_RADIUS, '#ff2a2a', 30, 10, 4);
          spawnFloatingText(CENTER_X, state.targetY + 60, "SHIELD BREAK!", '#ff2a2a', 20);
        }
      });
      
      if (destroyedCount > 0) {
        state.score += destroyedCount * 100;
        spawnFloatingText(CENTER_X, CENTER_Y + 50, "LASER ERASE!", '#ffff00', 28);
      }
      checkWaveProgress();
      updateUI();
    }


    // --- メイン更新ループ ---
    function update() {
      CENTER_X = canvas.width / 2;
      CENTER_Y = canvas.height * 0.35;
      WAIT_PIN_Y = canvas.height * 0.85;

      state.cooldowns.forEach((cd, i) => { if (cd > 0) state.cooldowns[i]--; });

      // フィーバー管理（UIへの反映）
      const wasFever = state.isFever;
      state.isFever = Date.now() < state.feverEndTime;
      if (state.isFever !== wasFever) {
        document.getElementById('feverIndicator').classList.toggle('active', state.isFever);
        document.body.classList.toggle('fever-mode', state.isFever);
      }

      if (state.hitstopTimer > 0) {
        state.hitstopTimer--;
      } else {
        // ★ 的のムービング処理（WAVE 2以降） ★
        if (state.wave >= 2) {
          state.timePhase += 0.02 + (state.wave * 0.005); // WAVEが進むほど少し速く
          // 画面外に行かないよう、移動幅を制限
          const moveRadiusX = Math.min(30 + state.wave * 5, CONFIG.TARGET_RADIUS * 0.7);
          const moveRadiusY = Math.min(20 + state.wave * 3, 40);
          state.targetX = CENTER_X + Math.sin(state.timePhase) * moveRadiusX;
          state.targetY = CENTER_Y + Math.cos(state.timePhase * 0.8) * moveRadiusY;
        } else {
          state.targetX = CENTER_X;
          state.targetY = CENTER_Y;
        }

        const rotSpeed = state.isFever ? CONFIG.BASE_ROTATION_SPEED * 2.5 : CONFIG.BASE_ROTATION_SPEED;
        state.rotationAngle = normalizeAngle(state.rotationAngle + rotSpeed);

        // 飛んでいる針の更新と衝突判定
        for (let i = state.flyingPins.length - 1; i >= 0; i--) {
          const pin = state.flyingPins[i];
          pin.y -= CONFIG.FLY_SPEED;

          // 針（X座標は常に CENTER_X）と、的（targetX, targetY）の距離を計算
          const dx = CENTER_X - state.targetX;
          
          // X軸のズレが的の半径より大きい場合（完全に避けてしまった場合）は通り過ぎる
          if (Math.abs(dx) > CONFIG.TARGET_RADIUS) {
            if (pin.y < -100) state.flyingPins.splice(i, 1);
            continue;
          }

          // 的の円周上の「針が当たるY座標」をピタゴラスの定理で計算
          const dy = Math.sqrt(Math.pow(CONFIG.TARGET_RADIUS, 2) - Math.pow(dx, 2));
          const hitY = state.targetY + dy; // 下半球

          // 的に到達！
          if (pin.y <= hitY) {
            // 到達した瞬間の「的の中心から見た絶対角度」と「相対角度」
            const hitAngleAbs = Math.atan2(hitY - state.targetY, CENTER_X - state.targetX);
            const hitAngleRel = normalizeAngle(hitAngleAbs - state.rotationAngle);

            // 1. シールドとの衝突判定
            let hitShieldIndex = -1;
            for (let s = 0; s < state.shields.length; s++) {
              if (!state.shields[s].active) continue;
              if (getAngleDiff(hitAngleRel, state.shields[s].angleOffset) < state.shields[s].span / 2 + 0.1) {
                hitShieldIndex = s; break;
              }
            }

            if (hitShieldIndex !== -1) {
              // 【シールドに当たった場合】
              if (pin.type === 0) {
                // ノーマル針：弾き返されてコンボリセット
                applyHitstop(3);
                spawnParticles(CENTER_X, hitY, '#ffffff', 5, 3, 2);
                spawnFloatingText(CENTER_X, hitY, "BLOCKED!", '#ff2a2a', 16);
                state.combo = 0;
                state.flyingPins.splice(i, 1);
                updateUI();
                continue; // 処理終了
              } else if (pin.type === 1) {
                // BOMB：シールドを粉砕！
                state.shields[hitShieldIndex].active = false;
                applyHitstop(CONFIG.HITSTOP_FRAMES_HEAVY);
                applyScreenShake(15, 12);
                applyFlash(0.6);
                spawnParticles(CENTER_X, hitY, '#ff2a2a', 40, 10, 5);
                spawnFloatingText(CENTER_X, hitY, "SHIELD BREAK!", '#ff2a2a', 24);
                state.score += 200;
                // ※BOMBの爆風判定（針の巻き込み）はそのまま下に流して実行させる
              }
            }

            // 2. 既存の針との衝突判定
            let collidedWith = -1;
            for (let j = 0; j < state.pins.length; j++) {
              if (getAngleDiff(hitAngleRel, state.pins[j]) < CONFIG.COLLISION_MARGIN) {
                collidedWith = j; break;
              }
            }

            if (pin.type === 0) {
              // --- ノーマル針 ---
              if (collidedWith !== -1) {
                // 針を破壊
                state.pins.splice(collidedWith, 1);
                state.score += (state.isFever ? 100 : 50);
                state.combo = 0;
                
                applyHitstop(CONFIG.HITSTOP_FRAMES_DESTROY);
                applyScreenShake(8, 8); applyFlash(0.3);
                spawnParticles(CENTER_X, hitY, '#00ffff', 25, 6, 3);
                spawnFloatingText(CENTER_X, hitY, "DESTROY!", '#00ffff');
              } else {
                // 隙間に刺さる
                state.pins.push(hitAngleRel);
                state.combo++;
                state.score += 10 * state.combo * (state.isFever ? 2 : 1);
                
                applyHitstop(CONFIG.HITSTOP_FRAMES_NORMAL);
                spawnParticles(CENTER_X, hitY, '#ffffff', 10, 3, 2);
                spawnFloatingText(CENTER_X, hitY, "+" + (10*state.combo), '#ffffff', 16);

                // フィーバー発動判定
                if (!state.isFever && state.combo >= 10) {
                  state.feverEndTime = Date.now() + 4000;
                  applyScreenShake(20, 10); applyFlash(0.6);
                  spawnFloatingText(CENTER_X, CENTER_Y, "FEVER!!", '#ffff00', 40);
                }
              }

            } else if (pin.type === 1) {
              // --- 爆発針 ---
              applyHitstop(CONFIG.HITSTOP_FRAMES_HEAVY);
              applyScreenShake(15, 12); applyFlash(0.6);
              spawnParticles(CENTER_X, hitY, '#ff2a2a', 40, 10, 5);
              
              let destroyed = 0;
              const newPins = [];
              state.pins.forEach(p => {
                if (getAngleDiff(hitAngleRel, p) < 0.5) {
                  destroyed++;
                  const pAbsX = state.targetX + Math.cos(state.rotationAngle+p)*CONFIG.TARGET_RADIUS;
                  const pAbsY = state.targetY + Math.sin(state.rotationAngle+p)*CONFIG.TARGET_RADIUS;
                  spawnParticles(pAbsX, pAbsY, '#ff8800', 5, 5, 2);
                } else {
                  newPins.push(p);
                }
              });
              state.pins = newPins;
              
              if (destroyed > 0) {
                state.score += destroyed * 150;
                spawnFloatingText(CENTER_X, hitY, "BOOM!", '#ff2a2a', 30);
              }
            }

            state.flyingPins.splice(i, 1);
            checkWaveProgress();
            updateUI();
          }
        }
      } 

      // エフェクト更新
      if (state.screenShakeTimer > 0) state.screenShakeTimer--;
      if (state.flashAlpha > 0) state.flashAlpha -= CONFIG.FLASH_DECAY;
      if (state.laserBeamTimer > 0) state.laserBeamTimer--;

      // パーティクル制限（フィーバー時の負荷軽減）
      if (state.particles.length > 300) state.particles.splice(0, state.particles.length - 300);
      
      for (let i = state.particles.length - 1; i >= 0; i--) {
        const p = state.particles[i];
        p.x += p.vx; p.y += p.vy; p.life -= p.decay;
        if (p.life <= 0) state.particles.splice(i, 1);
      }
      for (let i = state.floatingTexts.length - 1; i >= 0; i--) {
        const t = state.floatingTexts[i];
        t.y += t.vy; t.life -= 0.02;
        if (t.life <= 0) state.floatingTexts.splice(i, 1);
      }
    }


    // --- 描画処理 ---
    function drawPin(x, y, angle, color) {
      ctx.save();
      ctx.translate(x, y); ctx.rotate(angle);
      ctx.shadowBlur = 10; ctx.shadowColor = color;
      ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(CONFIG.PIN_LENGTH, 0);
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; ctx.stroke();
      ctx.beginPath(); ctx.arc(CONFIG.PIN_LENGTH, 0, CONFIG.PIN_HEAD_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = color; ctx.fill();
      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();

      if (state.screenShakeTimer > 0) {
        const mag = state.shakeMagnitude * (state.screenShakeTimer / 20);
        ctx.translate(random(-mag, mag), random(-mag, mag));
      }

      // レーザーの描画
      if (state.laserBeamTimer > 0) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = `rgba(255, 255, 0, ${state.laserBeamTimer / 15})`;
        ctx.shadowBlur = 30; ctx.shadowColor = '#ffff00';
        ctx.fillRect(CENTER_X - 15, state.targetY - CONFIG.TARGET_RADIUS, 30, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.fillRect(CENTER_X - 5, state.targetY - CONFIG.TARGET_RADIUS, 10, canvas.height);
        ctx.restore();
      }

      // 的本体の描画
      ctx.save();
      ctx.translate(state.targetX, state.targetY);
      ctx.rotate(state.rotationAngle);
      ctx.shadowBlur = state.isFever ? 30 : 15;
      ctx.shadowColor = state.isFever ? '#ffff00' : CONFIG.WEAPONS[0].color;
      
      ctx.beginPath();
      ctx.arc(0, 0, CONFIG.TARGET_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = '#050510'; ctx.fill();
      ctx.lineWidth = 5;
      ctx.strokeStyle = state.isFever ? '#ffff00' : CONFIG.WEAPONS[0].color;
      ctx.stroke();

      // ★ シールドの描画（的と一緒に回転する） ★
      state.shields.forEach(sh => {
        if (!sh.active) return;
        ctx.beginPath();
        // 的より少し外側に赤い弧を描画
        ctx.arc(0, 0, CONFIG.TARGET_RADIUS + 15, sh.angleOffset - sh.span/2, sh.angleOffset + sh.span/2);
        ctx.strokeStyle = '#ff2a2a';
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.shadowBlur = 15; ctx.shadowColor = '#ff2a2a';
        ctx.stroke();
      });

      ctx.restore();

      // 刺さっている針（的の座標を基準に描画）
      state.pins.forEach(p => {
        const ang = state.rotationAngle + p;
        drawPin(state.targetX + Math.cos(ang)*CONFIG.TARGET_RADIUS, 
                state.targetY + Math.sin(ang)*CONFIG.TARGET_RADIUS, 
                ang, CONFIG.WEAPONS[0].color);
      });

      // 飛んでいる針（発射位置から）
      state.flyingPins.forEach(pin => {
        drawPin(CENTER_X, pin.y, -Math.PI / 2, CONFIG.WEAPONS[pin.type].color);
      });

      // 待機中の針
      if (state.currentWeapon !== 2 && (state.isFever || state.cooldowns[state.currentWeapon] <= 0)) {
        drawPin(CENTER_X, WAIT_PIN_Y, -Math.PI / 2, CONFIG.WEAPONS[state.currentWeapon].color);
      }

      // パーティクル
      ctx.globalCompositeOperation = 'lighter';
      state.particles.forEach(p => {
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, p.life); ctx.fill();
      });
      ctx.globalAlpha = 1.0; ctx.globalCompositeOperation = 'source-over';

      // ポップアップテキスト
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      state.floatingTexts.forEach(t => {
        ctx.font = `bold ${t.size}px Orbitron, sans-serif`;
        ctx.fillStyle = t.color; ctx.globalAlpha = Math.max(0, t.life);
        ctx.shadowBlur = 10; ctx.shadowColor = t.color;
        ctx.fillText(t.text, t.x, t.y);
      });
      ctx.globalAlpha = 1.0; ctx.shadowBlur = 0;

      ctx.restore();

      if (state.flashAlpha > 0) {
        ctx.fillStyle = `rgba(255, 255, 255, ${state.flashAlpha})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    // --- UIの更新 ---
    function updateUI() {
      document.getElementById('scoreValue').innerText = state.score;
      document.getElementById('comboValue').innerText = state.combo;
      document.getElementById('comboValue').style.transform = `scale(${1 + state.combo*0.05})`;
    }

    function updateCooldownUI() {
      CONFIG.WEAPONS.forEach((wp, i) => {
        const fill = document.getElementById(`cdFill${i}`);
        if (state.isFever) {
          fill.style.height = `0%`; // フィーバー中はゲージなし
        } else if (wp.cdTime > 0) {
          const ratio = (state.cooldowns[i] / wp.cdTime) * 100;
          fill.style.height = `${ratio}%`;
        }
      });
    }

    // --- メインループ ---
    function gameLoop() {
      update();
      draw();
      updateCooldownUI();
      requestAnimationFrame(gameLoop);
    }

    // --- 入力イベント ---
    canvas.addEventListener('pointerdown', (e) => { e.preventDefault(); shoot(); });
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); shoot(); }
      if (e.key === '1') setWeapon(0);
      if (e.key === '2') setWeapon(1);
      if (e.key === '3') setWeapon(2);
    });

    updateUI();
    gameLoop();

  </script>
</body>
</html>
